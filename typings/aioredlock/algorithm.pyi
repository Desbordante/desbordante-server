import logging
from typing import Any, Dict, List, Optional, Tuple, Union

from aioredlock.errors import LockError as LockError
from aioredlock.lock import Lock as Lock
from aioredlock.redis import Redis as Redis
from aioredlock.utility import clean_password as clean_password

class Aioredlock:
    redis_connections: List[Union[Dict[str, Any], str, Tuple[str, int]]]
    retry_count: int
    retry_delay_min: float
    retry_delay_max: float
    internal_lock_timeout: float
    redis: Redis

    def __init__(
        self,
        redis_connections: List[Union[Dict[str, Any], str, Tuple[str, int]]] = ...,
        retry_count: int = 3,
        retry_delay_min: float = 0.1,
        retry_delay_max: float = 0.3,
        internal_lock_timeout: float = 10.0,
    ) -> None: ...
    def __attrs_post_init__(self) -> None: ...
    @property
    def log(self) -> logging.Logger: ...
    async def lock(
        self,
        resource: str,
        lock_timeout: Optional[float] = None,
        lock_identifier: Optional[str] = None,
    ) -> Lock: ...
    async def extend(
        self, lock: Lock, lock_timeout: Optional[float] = None
    ) -> None: ...
    async def unlock(self, lock: Lock) -> None: ...
    async def is_locked(self, resource_or_lock: Union[str, Lock]) -> bool: ...
    async def destroy(self) -> None: ...
    async def get_active_locks(self) -> List[Lock]: ...
    async def get_lock(self, resource: str, lock_identifier: str) -> Optional[Lock]: ...
    def __lt__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
